

/*
*1.任何的一个引用类型都是堆内存
*2.任何一个作用域和固定的值都是栈内存
* */
;(function(){
    //这个时候有两个变量的值指向这个堆内存的地址，所以这个内存是不会释放的
    var obj1={name:"leo"};
    var obj2=obj1;
    //两个变量的指向全部都修改了指向，现在是没有变脸执行那个堆内存的地址了，过一段时间后这个内存就会释放
    obj1=null;
    obj2=null;
})();

/*
*1.google 过一段时间会扫描一遍，然后清除掉
*2.fireFox 和 IE 会通过记录指向的地址的变量数量，当为零的时候就会释放
*3.IE 容易记错，造成内存泄露
* */

/*
* 栈内存一般分为两种
* 1.全局作用域
* 2.私有作用域(函数的执行的时候会创建函数作用域)
*
* 1.只有当页面关闭的时候全局的作用域才会销毁
* 2.私有的作用域，
* 一般的情况，函数的执行会创建一个私有的作用域，当私有作用域中的代码执行完成后，我们的当前作用域都会主动的执行释放和销毁
* 但是特殊情况
* 如果当前作用域中的部分内容被作用域意外的东西占用了，那么当前的作用域就不会进行销毁了
* 一般一个函数执行了，然后返回一个引用类型的值，被一个值获取到了，这样的一般作用域都不会进行销毁，哪怕返回一个{}
*例如1
* 还有就是在一个方法中有一个dom 绑定了私有作用域中的一个引用类型的东西，然后就该私用的作用域就不会释放
* 例如2
* 还有一种情况是不会立即的销毁
* 例如3
* */

;(function(){
    return;
    function fn(){
        var num=10;
        return function(){

        }
    }
    //fn执行的这个私有的作用域就不会被销毁
    var f=fn();
})();


/*
* 当前自执行的函数所执行形成的自执行函数也不会销毁
* 因为div的onclick 已经保存了一个自执行函数中的一个引用类型的值，所以也不会释放这块的内容
* */
;(function(){
    var div=document.querySelector('id');
    ~function(){
        div.onclick=function(){

        }
    };
})();

/*
*
* */
;(function (){
    function fn(){
        var num=100;
        return function (){

        }
    }
    //不立即销毁，在第二次调用结束之后会销毁
    fn()();
})();